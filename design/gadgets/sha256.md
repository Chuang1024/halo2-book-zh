# SHA-256

## Specification

SHA-256 is specified in [NIST FIPS PUB 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).

Unlike the specification, we use $\boxplus$ for addition modulo $2^{32}$, and $+$ for
field addition. $\oplus$ is used for XOR.

## Gadget interface

SHA-256 maintains state in eight 32-bit variables. It processes input as 512-bit blocks,
but internally splits these blocks into 32-bit chunks. We therefore designed the SHA-256
gadget to consume input in 32-bit chunks.

## Chip instructions

The SHA-256 gadget requires a chip with the following instructions:

```rust
# extern crate halo2_proofs;
# use halo2_proofs::plonk::Error;
# use std::fmt;
#
# trait Chip: Sized {}
# trait Layouter<C: Chip> {}
const BLOCK_SIZE: usize = 16;
const DIGEST_SIZE: usize = 8;

pub trait Sha256Instructions: Chip {
    /// Variable representing the SHA-256 internal state.
    type State: Clone + fmt::Debug;
    /// Variable representing a 32-bit word of the input block to the SHA-256 compression
    /// function.
    type BlockWord: Copy + fmt::Debug;

    /// Places the SHA-256 IV in the circuit, returning the initial state variable.
    fn initialization_vector(layouter: &mut impl Layouter<Self>) -> Result<Self::State, Error>;

    /// Starting from the given initial state, processes a block of input and returns the
    /// final state.
    fn compress(
        layouter: &mut impl Layouter<Self>,
        initial_state: &Self::State,
        input: [Self::BlockWord; BLOCK_SIZE],
    ) -> Result<Self::State, Error>;

    /// Converts the given state into a message digest.
    fn digest(
        layouter: &mut impl Layouter<Self>,
        state: &Self::State,
    ) -> Result<[Self::BlockWord; DIGEST_SIZE], Error>;
}
```

TODO: Add instruction for computing padding.

This set of instructions was chosen to strike a balance between the reusability of the
instructions, and the scope for chips to internally optimise them. In particular, we
considered splitting the compression function into its constituent parts (Ch, Maj etc),
and providing a compression function gadget that implemented the round logic. However,
this would prevent chips from using relative references between the various parts of a
compression round. Having an instruction that implements all compression rounds is also
similar to the Intel SHA extensions, which provide an instruction that performs multiple
compression rounds.


# SHA-256

## 规范

SHA-256 在 [NIST FIPS PUB 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf) 中定义。

与规范不同的是，我们使用 $\boxplus$ 表示模 $2^{32}$ 的加法，使用 $+$ 表示域加法。$\oplus$ 用于表示异或。

## Gadget 接口

SHA-256 在八个 32 位变量中维护状态。它以 512 位的块处理输入，但在内部将这些块分割为 32 位的块。因此，我们设计了 SHA-256 gadget 以 32 位的块为单位消耗输入。

## 芯片指令

SHA-256 gadget 需要一个支持以下指令的芯片：

```rust
# extern crate halo2_proofs;
# use halo2_proofs::plonk::Error;
# use std::fmt;
#
# trait Chip: Sized {}
# trait Layouter<C: Chip> {}
const BLOCK_SIZE: usize = 16;
const DIGEST_SIZE: usize = 8;

pub trait Sha256Instructions: Chip {
    /// 表示 SHA-256 内部状态的变量。
    type State: Clone + fmt::Debug;
    /// 表示 SHA-256 压缩函数输入块的 32 位字的变量。
    type BlockWord: Copy + fmt::Debug;

    /// 在电路中放置 SHA-256 的初始向量（IV），并返回初始状态变量。
    fn initialization_vector(layouter: &mut impl Layouter<Self>) -> Result<Self::State, Error>;

    /// 从给定的初始状态开始，处理一个输入块并返回最终状态。
    fn compress(
        layouter: &mut impl Layouter<Self>,
        initial_state: &Self::State,
        input: [Self::BlockWord; BLOCK_SIZE],
    ) -> Result<Self::State, Error>;

    /// 将给定的状态转换为消息摘要。
    fn digest(
        layouter: &mut impl Layouter<Self>,
        state: &Self::State,
    ) -> Result<[Self::BlockWord; DIGEST_SIZE], Error>;
}
```

待办：添加计算填充的指令。

选择这组指令是为了在指令的可重用性和芯片内部优化的空间之间取得平衡。特别是，我们曾考虑将压缩函数拆分为其组成部分（Ch、Maj 等），并提供一个实现轮逻辑的压缩函数 gadget。然而，这将阻止芯片在压缩轮的各部分之间使用相对引用。拥有一个实现所有压缩轮的指令也与 Intel SHA 扩展类似，后者提供了一个执行多个压缩轮的指令。
