# Proof systems

The aim of any ***proof system*** is to be able to prove interesting mathematical or
cryptographic ***statements***.

Typically, in a given protocol we will want to prove families of statements that differ
in their ***public inputs***. The prover will also need to show that they know some
***private inputs*** that make the statement hold.

To do this we write down a ***relation***, $\mathcal{R}$, that specifies which
combinations of public and private inputs are valid.

> The terminology above is intended to be aligned with the
> [ZKProof Community Reference](https://docs.zkproof.org/reference#latest-version).

To be precise, we should distinguish between the relation $\mathcal{R}$, and its
implementation to be used in a proof system. We call the latter a ***circuit***.

The language that we use to express circuits for a particular proof system is called an
***arithmetization***. Usually, an arithmetization will define circuits in terms of
polynomial constraints on variables over a field.

> The _process_ of expressing a particular relation as a circuit is also sometimes called
> "arithmetization", but we'll avoid that usage.

To create a proof of a statement, the prover will need to know the private inputs,
and also intermediate values, called ***advice*** values, that are used by the circuit.

We assume that we can compute advice values efficiently from the private and public inputs.
The particular advice values will depend on how we write the circuit, not only on the
high-level statement.

The private inputs and advice values are collectively called a ***witness***.

> Some authors use "witness" as just a synonym for private inputs. But in our usage,
> a witness includes advice, i.e. it includes all values that the prover supplies to
> the circuit.

For example, suppose that we want to prove knowledge of a preimage $x$ of a
hash function $H$ for a digest $y$:

* The private input would be the preimage $x$.

* The public input would be the digest $y$.

* The relation would be $\{(x, y) : H(x) = y\}$.

* For a particular public input $Y$, the statement would be: $\{(x) : H(x) = Y\}$.

* The advice would be all of the intermediate values in the circuit implementing the
  hash function. The witness would be $x$ and the advice.

A ***Non-interactive Argument*** allows a ***prover*** to create a ***proof*** for a
given statement and witness. The proof is data that can be used to convince a ***verifier***
that _there exists_ a witness for which the statement holds. The security property that
such proofs cannot falsely convince a verifier is called ***soundness***.

A ***Non-interactive Argument of Knowledge*** (***NARK***) further convinces the verifier
that the prover _knew_ a witness for which the statement holds. This security property is
called ***knowledge soundness***, and it implies soundness.

In practice knowledge soundness is more useful for cryptographic protocols than soundness:
if we are interested in whether Alice holds a secret key in some protocol, say, we need
Alice to prove that _she knows_ the key, not just that it exists.

Knowledge soundness is formalized by saying that an ***extractor***, which can observe
precisely how the proof is generated, must be able to compute the witness.

> This property is subtle given that proofs can be ***malleable***. That is, depending on the
> proof system it may be possible to take an existing proof (or set of proofs) and, without
> knowing the witness(es), modify it/them to produce a distinct proof of the same or a related
> statement. Higher-level protocols that use malleable proof systems need to take this into
> account.
>
> Even without malleability, proofs can also potentially be ***replayed***. For instance,
> we would not want Alice in our example to be able to present a proof generated by someone
> else, and have that be taken as a demonstration that she knew the key.

If a proof yields no information about the witness (other than that a witness exists and was
known to the prover), then we say that the proof system is ***zero knowledge***.

If a proof system produces short proofs —i.e. of length polylogarithmic in the circuit
size— then we say that it is ***succinct***. A succinct NARK is called a ***SNARK***
(***Succinct Non-Interactive Argument of Knowledge***).

> By this definition, a SNARK need not have verification time polylogarithmic in the circuit
> size. Some papers use the term ***efficient*** to describe a SNARK with that property, but
> we'll avoid that term since it's ambiguous for SNARKs that support amortized or recursive
> verification, which we'll get to later.

A ***zk-SNARK*** is a zero-knowledge SNARK.


# 证明系统

任何***证明系统***的目标是能够证明有趣的数学或密码学***陈述***。

通常，在给定的协议中，我们希望证明一系列因***公共输入***而不同的陈述。证明者还需要展示他们知道一些***私有输入***，使得陈述成立。

为此，我们写下了一个***关系***，$\mathcal{R}$，它指定了哪些公共和私有输入的组合是有效的。

> 上述术语旨在与 [ZKProof 社区参考](https://docs.zkproof.org/reference#latest-version) 保持一致。

为了精确起见，我们应该区分关系 $\mathcal{R}$ 和其在证明系统中使用的实现。我们称后者为***电路***。

我们用来为特定证明系统表达电路的语言称为***算术化***。通常，算术化会通过在域上的变量的多项式约束来定义电路。

> 将特定关系表达为电路的*过程*有时也被称为“算术化”，但我们将避免这种用法。

为了创建陈述的证明，证明者需要知道私有输入，以及电路使用的中间值，称为***建议***值。

我们假设可以从私有和公共输入中高效地计算出建议值。具体的建议值取决于我们如何编写电路，而不仅仅是高层陈述。

私有输入和建议值统称为***见证***。

> 一些作者将“见证”仅仅用作私有输入的同义词。但在我们的用法中，见证包括建议值，即它包括证明者提供给电路的所有值。

例如，假设我们想要证明对哈希函数 $H$ 的摘要 $y$ 的原像 $x$ 的知识：

* 私有输入将是原像 $x$。
* 公共输入将是摘要 $y$。
* 关系将是 $\{(x, y) : H(x) = y\}$。
* 对于特定的公共输入 $Y$，陈述将是：$\{(x) : H(x) = Y\}$。
* 建议值将是实现哈希函数的电路中的所有中间值。见证将是 $x$ 和建议值。

***非交互式论证***允许***证明者***为给定的陈述和见证创建***证明***。证明是可以用来说服***验证者***的数据，证明*存在*一个见证使得陈述成立。这种证明无法错误地说服验证者的安全属性称为***可靠性***。

***非交互式知识论证***​（***NARK***）进一步说服验证者证明者*知道*一个见证使得陈述成立。这种安全属性称为***知识可靠性***，它隐含了可靠性。

在实践中，知识可靠性比可靠性对密码协议更有用：例如，如果我们关心 Alice 是否在某个协议中持有秘密密钥，我们需要 Alice 证明她*知道*该密钥，而不仅仅是它存在。

知识可靠性通过说***提取器***​（可以精确观察证明的生成方式）必须能够计算出见证来形式化。

> 鉴于证明可以是***可塑的***，这一属性是微妙的。也就是说，根据证明系统，可能会拿一个现有的证明（或一组证明），并在不知道见证的情况下，修改它以生成相同或相关陈述的不同证明。使用可塑证明系统的高层协议需要考虑这一点。
>
> 即使没有可塑性，证明也可能被***重放***。例如，我们不希望 Alice 在我们的示例中能够展示由其他人生成的证明，并将其作为她知道密钥的证明。

如果证明不泄露见证的任何信息（除了存在见证且证明者知道它），那么我们说证明系统是***零知识的***。

如果证明系统生成短证明——即长度在电路大小的多对数范围内——那么我们说它是***简洁的***。简洁的 NARK 称为***SNARK***​（***简洁非交互式知识论证***）。

> 根据这个定义，SNARK 不需要在电路大小上具有多对数的验证时间。一些论文使用术语***高效的***来描述具有该属性的 SNARK，但我们将避免该术语，因为它对于支持摊销或递归验证的 SNARK 是模棱两可的，我们将在后面讨论。

***zk-SNARK*** 是一个零知识的 SNARK。